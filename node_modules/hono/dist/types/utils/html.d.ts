type HtmlEscapedCallbackOpts = {
    error?: Error;
    buffer?: [string];
};
export type HtmlEscapedCallback = (opts: HtmlEscapedCallbackOpts) => Promise<string>;
export type HtmlEscaped = {
    isEscaped: true;
    callbacks?: HtmlEscapedCallback[];
};
export type HtmlEscapedString = string & HtmlEscaped;
/**
 * StringBuffer contains string and Promise<string> alternately
 * The length of the array will be odd, the odd numbered element will be a string,
 * and the even numbered element will be a Promise<string>.
 * When concatenating into a single string, it must be processed from the tail.
 * @example
 * [
 *   'framework.',
 *   Promise.resolve('ultra fast'),
 *   'a ',
 *   Promise.resolve('is '),
 *   'Hono',
 * ]
 */
export type StringBuffer = (string | Promise<string>)[];
export declare const stringBufferToString: (buffer: StringBuffer) => Promise<HtmlEscapedString>;
export declare const escapeToBuffer: (str: string, buffer: StringBuffer) => void;
export declare const resolveStream: (str: string | HtmlEscapedString, buffer?: [string]) => Promise<string>;
export {};
