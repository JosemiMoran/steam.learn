// src/jsx/streaming.ts
import { raw } from "../helper/html/index.js";
import { childrenToString } from "./components.js";
var suspenseCounter = 0;
var Suspense = async ({ children, fallback }) => {
  if (!children) {
    return fallback.toString();
  }
  if (!Array.isArray(children)) {
    children = [children];
  }
  let resArray = [];
  try {
    resArray = children.map((c) => c.toString());
  } catch (e) {
    if (e instanceof Promise) {
      resArray = [e.then(() => childrenToString(children))];
    } else {
      throw e;
    }
  }
  if (resArray.some((res) => res instanceof Promise)) {
    const index = suspenseCounter++;
    return raw(`<template id="H:${index}"></template>${fallback.toString()}<!--/$-->`, [
      ({ buffer }) => {
        return Promise.all(resArray).then((htmlArray) => {
          htmlArray = htmlArray.flat();
          const content = htmlArray.join("");
          if (buffer) {
            buffer[0] = buffer[0].replace(
              new RegExp(`<template id="H:${index}"></template>.*?<!--/\\$-->`),
              content
            );
          }
          const html = buffer ? "" : `<template>${content}</template><script>
((d,c,n) => {
c=d.currentScript.previousSibling
d=d.getElementById('H:${index}')
if(!d)return
do{n=d.nextSibling;n.remove()}while(n.nodeType!=8||n.nodeValue!='/$')
d.replaceWith(c.content)
})(document)
<\/script>`;
          if (htmlArray.every((html2) => !html2.callbacks?.length)) {
            return html;
          }
          return raw(
            html,
            htmlArray.map((html2) => html2.callbacks || []).flat()
          );
        });
      }
    ]);
  } else {
    return raw(resArray.join(""));
  }
};
var textEncoder = new TextEncoder();
var renderToReadableStream = (str) => {
  const reader = new ReadableStream({
    async start(controller) {
      const resolved = str instanceof Promise ? await str : await str.toString();
      controller.enqueue(textEncoder.encode(resolved));
      let resolvedCount = 0;
      const callbacks = [];
      const then = (promise) => {
        callbacks.push(
          promise.catch((err) => {
            console.trace(err);
            return "";
          }).then((res) => {
            if (res.callbacks) {
              const callbacks2 = res.callbacks || [];
              callbacks2.map((c) => c({})).forEach(then);
            }
            resolvedCount++;
            controller.enqueue(textEncoder.encode(res));
          })
        );
      };
      resolved.callbacks?.map((c) => c({})).forEach(then);
      while (resolvedCount !== callbacks.length) {
        await Promise.all(callbacks);
      }
      controller.close();
    }
  });
  return reader;
};
export {
  Suspense,
  renderToReadableStream
};
